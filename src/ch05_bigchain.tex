\section{BigchainDB Description}\label{sec:bigchaindb}

\subsection{Principles}
Rather than trying to scale up blockchain technology, BigchainDB starts with a “big data” distributed database, and adds blockchain characteristics.
It avoids the technology choices that plague Bitcoin, such as full replication and broadcast communication.

We built BigchainDB on top of an enterprise-grade distributed DB, from which BigchainDB inherits high throughput, high capacity, a full-featured NoSQL query language, efficient querying, and permissioning. Nodes can be added to increase throughput and capacity.

Since the big data DB has its own built-in consensus algorithm to tolerate benign faults, we exploit that solution directly.
We “get out of the way” of the algorithm to let it decide which transactions to write, and what the block order is.
We disallow private, peer-to-peer communication between the nodes except via the DB’s built-in communication, for great savings in complexity and for reduced security risk\footnote{Though we must vigilantly exercise restraint in design, as intuition is to just get the nodes talking directly!}.
This means that malicious nodes cannot transmit one message to part of the network and different message to other part of the network. Everytime a node ``speaks,'' all the others can listen.

\subsection{High-Level Description}
We focused on adding the following blockchain features to the DB:
\begin{enumerate}
 \item \textbf{Decentralized control}, where “no one” owns or controls a network;
 \item \textbf{Immutability}, where written data is tamper-resistant (“forever”); and
 \item \textbf{The ability to create \& transfer assets} on the network, without reliance on a central entity.
\end{enumerate}

Decentralized control is achieved via a DNS-like federation of nodes with voting permissions.
Other nodes can connect to read, and propose transactions; this makes it a super-peer P2P network \cite{ozsu2011principles}.
The voting operates at a layer above the DB’s built in consensus.
Quorum is a majority of votes.
For speed, all transactions are written independent of their validity; votes are done \textit{a posteriori}.

Immutability is via an ordered sequence of blocks where each block holds an ordered sequence of transactions; and a block’s hash is over its transactions and related data; that is, a block chain.
Blocks are written, then voted upon.
Chainification actually happens at voting time.
A block doesn't have a top-level link to the previous block.
Instead, it has a list of votes, and each vote has a “previous block” attribute pointing to the id of the block coming before it.

Any entity with asset-issuance permissions can issue an asset; any entity with asset-transfer permissions and the asset’s private key may transfer the asset.
This means hackers or compromised system admins cannot arbitrarily change data, and there is no single-point-of-failure risk.

\subsection{Architecture}
Figure \ref{fig:bigchaindb_architecture} illustrates the architecture of the BigchainDB system.
The BigchainDB system presents its API to clients as if it was a single blockchain database.
Under the hood, there are actually two distributed databases\footnote{This can be implemented as two databases, or as two tables in the same database. While there is no practical difference, for the sake of clarity we describe it as two separate databases.}, $\mathbf{S}$ (transaction set or “backlog”) and $\mathbf{C}$ (block chain), connected by the BigchainDB Consensus Algorithm (BCA).
The BCA runs on each signing node.
Non-signing clients may connect to BigchainDB; depending on permissions they may be able to read, issue assets, transfer assets, and more; section~\ref{sec:permissioning} explores this more.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.7\textwidth]{figure_3.pdf}
  \caption{Architecture of BigchainDB system.
  There are two big data distributed databases: a Transaction Set $\mathbf{S}$ (left) to take in and assign incoming transactions, and a Blockchain $\mathbf{C}$ (right) holding ordered transactions that are “etched into stone”.
  The signing nodes running the BigchainDB Consensus Algorithm update $\mathbf{S}$, $\mathbf{C}$, and the transactions (txs) between them.}
  \label{fig:bigchaindb_architecture}
\end{figure}

Each of the distributed DBs, $\mathbf{S}$ and $\mathbf{C}$, is an off-the-shelf big data DB.
We do not interfere with the internal workings of each DB; in this way, we get to leverage the scalability properties of the DBs, in addition to features like revision control and benefits like battle-tested code.
Each DB is running its own internal Paxos-like consensus algorithm for consistency among the drives.

The first DB holds the “backlog” transactions---an unordered set of transactions~$\mathbf{S}$.
When a transaction comes in, it gets validated by the receiving node and if it's valid (according to that node), then it gets stored in $\mathbf{S}$. (Identical transactions arriving later will be rejected.) The receiving node also randomly assigns the transaction to one of the other nodes.

There are $N$ signing nodes. $\mathbf{S}_k = \{\mathbf{t}_{k,1}, \mathbf{t}_{k,2}, \dots\}$ is the set of transactions assigned to node $\mathbf{k}$.

Node $\mathbf{k}$ running the BigchainDB Consensus Algorithm (BCA) processes transactions from $\mathbf{S}$ as follows: It moves transactions from the unordered set $\mathbf{S}_k$ into an ordered list, creates a block for the transactions, and puts the block into the second database $\mathbf{C}$.
$\mathbf{C}$ is an ordered list of blocks where each block has reference to a parent block and its data, that is, a blockchain.

A signing node can vote on whether it considers a block \textsf{\textit{valid}} or \textsf{\textit{invalid}}. To decide, the signing node checks the validity of every transaction in the block, and if it finds an invalid transaction, then the signing node votes that the block is \textsf{\textit{invalid}}.
If the signing node finds no invalid transactions, then it votes that the block is \textsf{\textit{valid}}.

Each block starts out as \textsf{\textit{undecided}}, with no votes from signing nodes.
Once there is majority of positive (\textsf{\textit{valid}}) votes for a block, or a majority of negative (\textsf{\textit{invalid}}) votes, the block goes from \textsf{\textit{undecided}} to \textsf{\textit{decided\_valid}} or \textsf{\textit{decided\_invalid}}, respectively, and voting on the block stops.
Once it is decided, it can be treated as “etched into stone.” This process is similar to the idea of multiple confirmations in Bitcoin blockchain.

A block $\mathbf{B}$ in the blockchain has an ID, timestamp, the actual transactions, and vote information. Section \ref{subsec:bigchaindb:models} describes block, transaction, and voting models precisely.

\subsection{Behavioral Description}
This section examines the flow of transactions from a client to a given server node.
Each server node has its own view of the transaction backlog $\mathbf{S}$, and the chain $\mathbf{C}$.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=\textwidth]{figure_4.pdf}
  \caption{\textit{Left:} BigchainDB’s backlog $\mathbf{S}$ and chain $\mathbf{C}$ start empty.
  \textit{Right:} Clients have inserted transactions into backlog $\mathbf{S}$ and assigned to nodes 1, 3, and 2.}
  \label{fig:bigchaindb_architecture_step1}
\end{figure}

Figure \ref{fig:bigchaindb_architecture_step1} and subsequent figures illustrate the high-level architecture where each card is a physical machine.
The client machines are on the left\footnote{In some images, we truncate the illustration of the client, for brevity.}.
Clients are connected to the BigchainDB server node(s) (voting node), shown on the right. Any client may send transactions to any BigchainDB server node.

In Figure \ref{fig:bigchaindb_architecture_step1} left, one client has a transaction with ID \textsf{$\#$A}, and a payload.
BigchainDB’s backlog $\mathbf{S}$ is empty; and the chain $\mathbf{C}$ is empty except for a genesis block with a null transaction.
Other clients also have transactions that they transmit to server nodes.

When a client submits a transaction, the receiving node assigns it to one of the federation nodes, possibly itself, and stores it in the backlog $\mathbf{S}$.
Figure \ref{fig:bigchaindb_architecture_step1} right illustrates an example state.
We see that node 1 is assigned three transactions, having IDs of \textsf{$\#$A}, \textsf{$\#$G}, and \textsf{$\#$H}.
Node 2 is assigned transactions with IDs \textsf{$\#$B} and \textsf{$\#$E}.
Node 3 is assigned to transactions, \textsf{$\#$D} and \textsf{$\#$C}. No transactions have been put onto the chain $\mathbf{C}$ yet.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=\textwidth]{figure_5.pdf}
  \caption{\textit{Left:} Node 1 has moved its assigned transactions from backlog $\mathbf{S}$ to chain $\mathbf{C}$.
  \textit{Right:} Node 3 has processed its assigned transactions too.}
  \label{fig:bigchaindb_architecture_step2}
\end{figure}

Figure \ref{fig:bigchaindb_architecture_step2} left shows a state where Node 1 has processed all the transactions assigned to it.
It has taken the transactions \textsf{$\#$A}, \textsf{$\#$G}, and \textsf{$\#$H} from the backlog $\mathbf{S}$, created a block to hold them, then written the block onto the chain $\mathbf{C}$.
The block points to $\mathbf{C}$’s previous block.

Figure \ref{fig:bigchaindb_architecture_step2} right shows where Node 3 has processed all of its assigned transactions too, and therefore written them as a block in chain $\mathbf{C}$.

When a block is first written to $\mathbf{C}$, it starts off as \textsf{\textsf{\textit{undecided}}}.
Each server node may vote positively (for) or negatively (against) a block.
A block should only be voted positively if all previous blocks are not \textsf{\textit{undecided}}, and all transactions in the block itself are valid.
As soon as there is a majority of positive votes for a block, or a majority of negative votes, the block goes from \textsf{\textit{undecided}} to \textsf{\textit{decided\_valid}} or \textsf{\textit{decided\_invalid}}, respectively.

In this example, the block created by Node 1 gets voted on, and becomes \textsf{\textit{decided\_valid}}.
Then, the block from node 3 gets voted on, and becomes \textsf{\textit{decided\_invalid}}.
In Figure \ref{fig:bigchaindb_architecture_step2} right, we depict the distinction as a clear background for \textsf{\textit{decided\_valid}}, versus a shaded background for \textsf{\textit{decided\_invalid}}.)

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.5\textwidth]{figure_6.pdf}
  \caption{Transactions from an invalid block (on right, shaded) get re-inserted into backlog $\mathbf{S}$ for re-consideration.}
  \label{fig:bigchaindb_architecture_step3}
\end{figure}

While the overall block was considered invalid, some of the transactions in the invalid block may have actually been valid, and so BigchainDB gives them another chance.
Figure \ref{fig:bigchaindb_architecture_step3} illustrates how: transactions \textsf{$\#$B} and \textsf{$\#$E} get re-inserted into backlog $\mathbf{S}$ for new consideration.
Figure \ref{fig:bigchaindb_architecture_step3} also shows how BigchainDB approaches storage of invalid blocks.
There’s a block in the chain $\mathbf{C}$ that is invalid.
However, BigchainDB doesn’t remove the block; there’s no need, as the block is already marked invalid, disk space is not a problem, and it’s faster and simpler to keep all blocks there.
Similarly, voting doesn’t stop after a block becomes decided, because it’s faster for each node to simply vote than the extra step to check whether voting is necessary.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=\textwidth]{figure_7.pdf}
  \caption{\textit{Left:} More than one client may talk to a given node.
  \textit{Right:} there are multiple nodes. Typically, a client connects to just one node (an arbitrarily picked one).}
  \label{fig:bigchaindb_architecture_sharding}
\end{figure}

Figure \ref{fig:bigchaindb_architecture_sharding} emphasizes how multiple machines are configured.
Figure \ref{fig:bigchaindb_architecture_sharding} left shows that more than one client may talk to a given node.
Figure \ref{fig:bigchaindb_architecture_sharding} right shows that there is more than one node, though each node has a view into the backlog $\mathbf{S}$ and the chain $\mathbf{C}$.


\subsection{Models}\label{subsec:bigchaindb:models}
\subsubsection{Transaction Model}
A transaction is an operation between the $\mathtt{current\_owner}$ and the $\mathtt{new\_owner}$ over the digital content described by hash.
For example, it could be a transfer of ownership of the digital content hash.
A transaction has the following attributes:

\begin{lstlisting}[style=json]
{
  "id": "<sha3 hash>",
  "transaction": {
    "current owner": "<pub-key>",
    "new owner": "<pub-key>",
    "input": "<sha3 hash>",
    "operation": "<string>",
    "timestamp": "<timestamp from client>", 
    "data": {
      "hash": "<sha3 hash>",
      ...
    } 
  },
  "signature": "<ECDSA signature of the transaction>"
}
\end{lstlisting}

Attribute details are:
\begin{itemize}
 \item $\mathtt{id}$: SHA3 hash of the transaction. The $\mathtt{id}$ is also the DB primary key.
 \item $\mathtt{current\_owner}$: Public key of the current owner of the digital content with hash $\mathtt{hash}$
 \item $\mathtt{new\_owner}$: Public key of the new owner of the digital content with hash $\mathtt{hash}$
 \item $\mathtt{input}$: SHA3 hash of the transaction in which the content was transferred to the user (similar to input in the Bitcoin blockchain). This will be extended to allow multiple inputs per transaction. 
 \item $\mathtt{operation}$: String representation of the operation being performed (REGISTER, TRANSFER, \ldots) to define how the transactions should be validated.
 \item $\mathtt{timestamp}$: Time of creation of the transaction in UTC. It's provided by the client.
 \item $\mathtt{data}$: JSON object describing the asset (digital content). It contains at least the field \texttt{hash}, which is a SHA3 hash of the digital content. 
 \item $\mathtt{signature}$: ECDSA signature of the transaction with the $\mathtt{current\_owner}$ private key
\end{itemize}

\subsubsection{Block Model}
A block contains a group of transactions and includes the hash of the hash of the previous block to build the chain, as follows:

\begin{lstlisting}[style=json]
{
  "id": "<sha3 hash of the list of transactions + timestamp + nodes_pubkeys>",
  "block": {
    "timestamp": "<block-creation timestamp>",
    "transactions": ["<list of transactions>"], 
    "node_pubkey": "<public key of the node creating the block>", 
    "voters": ["<list of federation nodes public keys>"]
  },
  "signature": "<signature of the block>",
  "votes": []
}
\end{lstlisting}

\begin{itemize}
  \item $\mathtt{id}$: SHA3 hash of the current block. This is also a DB primary key, to ensure that all blocks are unique. 
  \item $\mathtt{block}$: The actual block
    \begin{itemize}
      \item $\mathtt{timestamp}$: Timestamp when the block was created. It's provided by the node that created the block.
      \item $\mathtt{transactions}$: List of transactions to be included in the block 
      \item $\mathtt{node\_pubkey}$: The public key of the node that created the block 
      \item $\mathtt{voters}$: list of public keys of the federation nodes. Since the size of the federation may change over time this will tell us how many nodes existed in the federation when the block was created so that in a later point in time we can check that the block received the correct number of votes.
    \end{itemize}
  \item $\mathtt{signature}$: Signature of the block by the node that created the block
  \item $\mathtt{votes}$: Initially an empty list. As nodes vote, they append their votes to this list. (The structure of the votes is detailed below.)
\end{itemize}

\subsubsection{Vote Model}
This is the structure that each node will append to the block votes list. 

\begin{lstlisting}[style=json]
{
  "node_pubkey": "<the pubkey of the voting node>",
  "vote": {
    "voting_for_block": "<id of the block the node is voting for>",
    "previous_block": "<id of the block previous to this one>", 
    "is_block_valid": "<true|false>", 
    "invalid_reason": "<None|DOUBLE_SPEND|TRANSACTIONS_HASH_MISMATCH|NODES_PUBKEYS_MISMATCH>", 
    "timestamp": "<timestamp of the voting action>" 
  },
  "signature": "<ECDSA signature of vote block>" 
}
\end{lstlisting}


\subsection{Block Validity and Blockchain Pipelining}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=\textwidth]{figure_8.pdf}
  \caption{Pipelining in the BigchainDB blockchain $\mathbf{C}$.
  Votes accumulate on each block.
  Blocks can continue to accumulate on the blockchain, even though their parents, grandparents, etc. may be undecided.
  The key is that when adding a new block, we can include transactions that do not depend on transactions in undecided blocks.}
  \label{fig:bigchaindb_chain_pipelining}
\end{figure}

Figure \ref{fig:bigchaindb_chain_pipelining} shows an example of a blockchain $\mathbf{C}$.
Block $\mathbf{B}_1$ is the genesis block with a null transaction.

Blocks are written to $\mathbf{C}$ in an order decided by the underlying DB.
This means that when a signing node inserts a block into $\mathbf{C}$, it cannot provide a vote at the same time (because a vote includes a reference to the previous block, but the previous block isn't known yet).
Only after the write is fully-committed does the block order become clear. 

Nodes vote on blocks after order becomes clear.
When a block is created, it starts off \textsf{\textit{undecided}}.
As soon as there is majority of positive votes for a block, or a majority of negative votes, the block goes from \textsf{\textit{undecided}} to \textsf{\textit{decided\_valid}} or \textsf{\textit{decided\_invalid}}, respectively.

Note that, unlike a typical block chain, the BigchainDB block model doesn't have a reference to the previous block.
Instead, it has a list of votes, and each vote has a reference to the previous block (i.e.~the block that the voting node considered the previous block, based on its view of the changefeed). We say that ``chainification happens at \textit{voting} time.''

Normally, all votes will reference the same previous block, but it's possible that different votes may claim that different blocks are the previous block. This can happen, for example, if a node goes down. When it comes back up, there's no reliable way to recover the order of the new blocks it missed while down. What should it put as the id/hash of the previous block? We will experiment with various options (e.g.~an id/hash value of ``null'' or the same id/hash as the majority of other votes).

If a node goes down, it won't accumulate a long list of new blocks that it must vote on when it comes back up. That's because the list of expected voters (nodes) for a block is set when that block is created. If a node is down when a block is created, then it won't be put on the list of expected voters for that block.

Block $\mathbf{B}_2$ has received three votes of five possible.
In this example, all three votes are positive.
Since the majority of nodes voted that the block is \textsf{\textit{valid}}, the block is considered \textsf{\textit{decided\_valid}}.

Block $\mathbf{B}_3$ has received five votes of five possible.
There was a positive vote, then negative, then positive, then two more negative votes.
Since the majority of nodes voted that the block is \textsf{\textit{invalid}}, the block is considered \textsf{\textit{decided\_invalid}}.
This block can stay in the chain because all the votes show that it is invalid.
It will be ignored when validating future transactions.
By keeping the block in place, we can quickly progress the chain to child blocks.

Block $\mathbf{B}_4$ is \textsf{\textit{undecided}} because it does not yet have a majority of invalid or valid votes from nodes.
Voting on $\mathbf{B}_4$ continues.

It is crucial that despite $\mathbf{B}_4$ being \textsf{\textit{undecided}}, it still has a child block $\mathbf{B}_5$.
This is possible because the DB’s built-in consensus algorithm determines the order of the blocks, and we have logically separated writing blocks from voting.
“Forking” is not a risk as it is not even in the vocabulary of the DB, let alone supported in code.
The reason is that every node is working on the same blockchain (instead of every node working on their own replica of the blockchain which may be different from the other nodes) and every node communicates through the database which is basically an open broadcast channel (instead of communicating individually with each node).
Because of this, any node can try to add a block, but only one becomes the child to $\mathbf{B}_4$; the rest follow according to the built-in consensus algorithm.
It is a single railroad track where the location of the next plank is based on previous planks.
We do not have to stop at adding a single plank after an undecided block—we can keep aggressively laying track, such as block $\mathbf{B}_6$ in the figure.

When there are undecided parent blocks, we need to do one more thing to prevent double-spending: any transaction put into a new block must not depend on transactions in an undecided block.
For example, inputs of a new transaction must not be in inputs of any undecided blocks.
This is enforced in two ways: when creating new blocks on undecided blocks, such double-spend transactions are not allowed, and when voting, any block containing such transactions is voted invalid.

We call this “blockchain pipelining” because this behavior is reminiscent of pipelining in microprocessors.
There, the microprocessor starts executing several possible instructions at once.
Once the microprocessor has worked out the proper order for the instructions, it collates the results as output and ignores useless results.
As with microprocessor pipelining, blockchain pipelining gives significant speed benefits.

\subsection{BigchainDB Consensus Algorithm (BCA)}

The BigChainDB Consensus Algorithm (BCA) is a state machine that runs on each “signing” node (server).
This section outlines the BCA using Python-like pseudocode.\footnote{The actual code will be open source, so if you’re curious about implementation details, you can read that.}

\subsubsection{Main Loop}

Before starting the $\mathtt{mainLoop()}$ on each signing node, the databases $\mathbf{S}$ and $\mathbf{C}$ must be created and initialized.
One of the initialization steps is to write a genesis block to $\mathbf{C}$.

Listing \ref{lst:bca} has high-level pseudocode for the BCA.
It shows the $\mathtt{mainLoop()}$ running on signing node $\mathbf{k}$.
Every signing node runs the same $\mathtt{mainLoop()}$.

Line $\mathtt{4}$ emphasizes that there is equal access by all the nodes to the databases $\mathbf{S}$ and $\mathbf{C}$. 
The BCA operates by moving data from transaction set $\mathbf{S}$ to blockchain $\mathbf{C}$, and occasionally in the other direction as well.

\begin{minipage}{\linewidth}
  \begin{lstlisting}[caption={BigchainDB Consensus Algorithm. This algorithm runs on every signing node.}, label={lst:bca}, style=python]
  def mainLoop(): # Pseudocode for signing node k 
    # Assume S and C exist and are initialized,
    # and C contains a genesis block. 
    global S, C # tx set and blockchain globally visible
    while True: 
      S = assignTransactions(S, k) 
      Sk, C = addBlock(Sk, C, k) 
      C = voteOnBlocks(C, k)
  \end{lstlisting}
\end{minipage}

Line $\mathtt{5}$ is the start of the main loop. All remaining pseudocode is part of this loop, which runs continuously until the node is shut down.

Line $\mathtt{6}$ accepts transactions into $\mathbf{S}$ and assigns them to nodes, line $\mathtt{7}$ moves unordered transactions from $\mathbf{S}$ into ordered, grouped-by-block transactions in $\mathbf{C}$, and line $\mathtt{8}$ is where the node votes on undecided blocks.

\begin{minipage}{\linewidth}
  \begin{lstlisting}[caption={Parallel version of BigchainDB Consensus Algorithm.}, label={lst:bca_parallel}, style=python]
  def mainLoopParallel():
    start => 1 assignTransactionLoop() processes 
    start => 1 addBlockLoop() processes 
    start => 1 voteLoop() processes
    
  def assignTransactionLoop():
    while True:
      S = assignTransactions(S, k)
  
  def addBlockLoop():
    while True:
      Sk, C = addBlock(Sk, C, k)
  
  def voteLoop():
    while True:
      C = voteOnBlocks(C, k)
  \end{lstlisting}
\end{minipage}

The pseudocode of Listing \ref{lst:bca} is written as if there is a single process, but each major step can actually be a separate, independent process.
In fact, there may be multiple processes doing each step; this helps performance tremendously.
Listing \ref{lst:bca_parallel} shows the pseudocode.

\subsubsection{Assigning Transactions}

\medskip
\noindent Listing \ref{lst:bca_tx_routines} algorithms are for assigning transactions, as follows:

Listing \ref{lst:bca_tx_routines} $\mathtt{assignTransactions()}$ is the main routine that groups the two major steps: accepting and assigning incoming transactions (line $\mathtt{2}$), and reassigning old transactions (line $\mathtt{3}$).

Listing \ref{lst:bca_tx_routines} $\mathtt{assignNewTransactions()}$ shows how a node accepts an incoming transaction from a client and assigns it to another node.
The receiving node first checks if the transaction is valid. If it's invalid, an error message is sent back to the client. If it's valid (according to the receiving node), it gets randomly assigned to one of the other nodes.
We assign transactions to a node rather than allowing nodes to grab transactions, because assignment greatly reduces double-spend detections in the block chain building side, and therefore helps throughput.
We considered assigning nodes deterministically, for example based on the hash of the transaction.
However, that would be problematic if a malicious node repeatedly inserted a bad transaction into $\mathbf{C}$, then when it got kicked back to $\mathbf{S}$, the malicious node got the same transaction again.
Instead, we assign the node randomly with equal probability to each node, except the current node $\mathbf{k}$ in order to avoid a duplicate vote.

In the algorithm, line~$\mathtt{7}$ accepts transactions and loops through them; line $\mathtt{8}$ checks the validity of the transaction; line $\mathtt{9}$ chooses which node to assign the transaction to, with uniform probability; line $\mathtt{11}$ records the assign time (see the next algorithm for why); and line $\mathtt{12}$ actually assigns the transaction to the chosen node.

\begin{minipage}{\linewidth}
  \begin{lstlisting}[caption={Routines for accepting and assigning transactions.}, label={lst:bca_tx_routines}, style=python, mathescape=true]
  def assignTransactions(S, k):
    S = assignNewTransactions(S, k) 
    S = reassignOldTransactions(S, k) 
    return S 
    
  def assignNewTransactions(S, k): 
    for each new tx, t from outside: 
      if t is valid:  # defined later
        i $\sim$ U({0, 1, $\dots$, k-1, k+1, $\dots$, N-1})
        # i is chosen randomly from all nodes but this one (k) 
        t.assign_time = time() 
        Si = Si $\cup$ t
      else:
        # inform the sending-client why t is not valid 
    return S 
    
  def reassignOldTransactions(S, k): 
    for Sj in {S1, S2, $\dots$}: 
      for each tx, t, in Sj: 
        if (time() - t.assign_time) > old_age_thr:
          i $\sim$ U({0, 1, $\dots$, k-1, k+1, $\dots$, N-1})
          t.assign_time = time()
          Si = Si $\cup$ t
          Sj = Sj - t
    return S
  \end{lstlisting}
\end{minipage}

Listing \ref{lst:bca_tx_routines} $\mathtt{reassignOldTransactions()}$ re-assigns transactions that are too old.
Transactions can get old if a node goes down, is running slowly, is acting maliciously, or is not performing its duties more generally.
This routine ensures transactions assigned to a node don't get stuck in limbo, by re-assigning old-enough transactions to different nodes.
It loops through all assigned transactions (lines $\mathtt{18}$-$\mathtt{19}$), and if a transaction is old enough (line $\mathtt{20}$) a new node is randomly chosen for it (line $\mathtt{21}$), a new assign time is set (line $\mathtt{22}$), and the transaction is re-assigned from the old node (node \textbf{j}) to the new node (node \textbf{i}).
For this routine to work, it also needs the unassigned-transactions to have an assign time, which is done in $\mathtt{assignNewTransactions()}$ (line $\mathtt{11}$)).


\subsubsection{Adding and Voting on Blocks}

\medskip
Listing \ref{lst:bca_block_add} $\mathtt{addBlock()}$ creates and adds a (non-genesis) block to $\mathbf{C}$, and ends with a set of transactions to postpone

\begin{minipage}{\linewidth}
  \begin{lstlisting}[caption={Routine for adding normal blocks.}, label={lst:bca_block_add}, style=python, mathescape=true]
  def addBlock(Sk, C, k):
    $\mathtt{T}_{\mathtt{postpone}}$ = {}
    $\mathtt{B}_{\mathtt{new}}$ = $\varnothing$
    $\mathtt{B}_{\mathtt{tail}}$ = most recent block in C
    $\mathtt{T}_{\mathtt{new}}$ = []
    for t in Sk:
      if dependsOnUndecidedBlock(t, $\mathtt{B}_{\mathtt{tail}}$):
        $\mathtt{T}_{\mathtt{postpone}}$ = $\mathtt{T}_{\mathtt{postpone}}$ $\cup$ t
      elif transactionValid(t, $\mathtt{B}_{\mathtt{tail}}$):
        $\mathtt{T}_{\mathtt{new}}$.append(t)
    id = sha3 hash of {$\mathtt{T}_{\mathtt{new}}$, other data wrt Sec. 5.5}
    votes = []
    $\mathtt{B}_{\mathtt{new}}$ = Block(id, $\mathtt{T}_{\mathtt{new}}$, votes, other data wrt Sec. 5.5)
    add $\mathtt{B}_{\mathtt{new}}$ to C # Consensus algorithm will determine order
    Sk = $\varnothing$
    Sk = Sk $\cup$ $\mathtt{T}_{\mathtt{postpone}}$
    return Sk, C
  \end{lstlisting}
\end{minipage}

Lines $\mathtt{2-3}$ initialize the routine’s main variables – the block to add $\mathbf{B}_{\mathtt{new}}$, and the transactions to postpone adding until later $\mathbf{T}_{\mathtt{postpone}}$.

Lines $\mathtt{4-17}$ creates a block and adds it to $\mathbf{C}$, in an order determined by $\mathbf{C}$’s consensus algorithm.
Line $\mathtt{4}$ updates its pointer $\mathbf{B}_{\mathtt{tail}}$ to the most recent block in $\mathbf{C}$.
It is important to grab $\mathbf{B}_{\mathtt{tail}}$ here rather than computing it on-the-fly, in case new blocks are added while the rest of the routine is running.
Line $\mathtt{5}$ initializes the ordered list of transactions to be added to the block, and lines $\mathtt{7-10}$ add them one at a time.
If a transaction $\mathbf{t}$ depends on an \textsf{\textit{undecided}} block (risking double-spend) it will be postponed to another block by being added to $\mathbf{T}_{\mathtt{postpone}}$ (lines $\mathtt{7-8}$).
Otherwise, if it is considered valid, then it is added to $\mathbf{T}_{\mathtt{new}}$ (lines $\mathtt{9-10}$).
Otherwise, it will be discarded. Lines $\mathtt{11-14}$ create the block and add it to $\mathbf{C}$.

Listing \ref{lst:bca_block_add} lines $\mathtt{15-16}$ occur once the block has been successfully added. With new transactions now in $\mathbf{C}$, those transactions can be removed from $\mathbf{S}$, as line $\mathtt{15}$ does by clearing $\mathbf{S}_k$.
Line $\mathtt{16}$ reconciles by adding back any postponed transactions, for example any transactions that risked being double-spends due to being added after an \textsf{\textit{undecided}} block.

\begin{minipage}{\linewidth}
  \begin{lstlisting}[caption={Routine for voting on blocks.}, label={lst:bca_block_vote}, style=python, mathescape=true]
  def voteOnBlocks(C, k): 
    B = oldest block in C that node k hasnt voted on
    while B: 
      vote = transactionsValid(B)
      B.V[k] = vote
      if B is decided and invalid: copy txs from B back into S 
      B = (child block of B) or $\varnothing$
    return C
  \end{lstlisting}
\end{minipage}

\noindent Listing \ref{lst:bca_block_vote}: Routine for voting on blocks $\mathtt{voteOnBlocks()}$ is the routine for node $\mathbf{k}$ to vote on blocks that it hasn’t yet voted on.

Note that a node actually votes on blocks that may have already been decided, because it’s faster to vote than to first query whether the block is decided.
Lines $\mathtt{3-8}$ iterate from the oldest block that node $\mathbf{k}$ hasn’t voted on (found in line $\mathtt{2}$) to the newest block (when temporary variable goes to $\varnothing$ in line $\mathtt{7}$).
For each block, line $\mathtt{4}$ computes a Boolean of whether all transactions in the block $\mathbf{B}$ are valid, and line $\mathtt{5}$ stores that in $\mathbf{B}$’s votes variable $\mathbf{B.V}$, signed by node $\mathbf{k}$.
Line $\mathtt{6}$ gives potentially valid transactions another chance.

\subsubsection{Transaction Validity}

\begin{minipage}{\linewidth}
  \begin{lstlisting}[caption={Routines for transaction validity.}, label={lst:bca_tx_valid}, style=python, mathescape=true]
  def transactionsValid(T, Bi):
    # are all txs valid?
    for t in T:
      if not transactionValid(t, Bi):
        return False
    return True
  
  def transactionValid(t, Bi):
    # Is tx valid in all blocks up to and including Bi? 
    # (Ignore Bi+1, Bi+2, $\dots$) 
    if t is ill-formed, commits double-spend, etc. 
      return False
    if dependsOnUndecidedBlock(t, Bi)
      return False
    return True
    
  def dependsOnUndecidedBlock(t, Bi):
    # returns True if any of the inputs of t are in a block 
    # that is not voted enough (enough x's or $\surd$'s) 
    # in [B0, B1, $\dots$ , Bi]. Ignores [Bi+1, Bi+2, $\dots$]
  \end{lstlisting}
\end{minipage}

\medskip
\noindent Listing \ref{lst:bca_tx_valid} outlines the routines for determining the validity of transactions.

\medskip
\noindent $\mathtt{transactionsValid()}$ is the top-level routine to simply loop through all the transactions supplied in the transaction list $\mathbf{T}$ (lines $\mathtt{3-6}$), and if any transaction is found to be invalid (line $\mathtt{4}$) the routine returns False.

\medskip
\noindent $\mathtt{transactionValid()}$ measures whether a transaction is valid, based on traditional blockchain validity measures (ill-formed, double-spend, etc.) in lines $\mathtt{11-12}$ and also based on whether it depends on an undecided block (lines $\mathtt{13-14}$).

\medskip
\noindent $\mathtt{dependsOnUndecidedBlock()}$ clarifies what it means to depend on an undecided block.

\subsection{Consensus Algorithm Checklist}
As we were designing the BCA, we addressed some concerns described below.

\medskip
\noindent\textbf{Block construction order.}
When a node finalizes the creation of a block, that block must not allow any more transactions to be added to it. This is to ensure that blocks created after the block can check that their transactions don't double-spend assets spent by previous blocks' transactions. This wouldn't be possible if a block could get more transactions added to it after block finalization.

\medskip
\noindent\textbf{Hashing votes.} 
Is there transaction malleability because votes are not hashed?
This may look like a problem, because a block’s hash can be propagated to its child block before all its votes are in.
A preliminary answer would be to have a second chain of hashes that actually includes the votes.
But the solution can be simpler than that: a hash without votes is fine because the votes are digitally signed by the signing nodes, and therefore not malleable.

\medskip
\noindent\textbf{Dropping transactions.} 
If a node goes down, what happens to the transactions assigned to it? Do those transactions get dropped?
In our initial design, the answer was mostly no, because all transactions are stored in $\mathbf{S}$ until they have been committed to a block.
However, if a node went down or, more generally misbehaved, transactions assigned to that node might not be handled.
To address this, we added a way to re-assign transactions if the previous node assignment got stale: algorithm $\mathtt{reassignOldTransactions()}$ in Listing \ref{lst:bca_tx_routines}.

\medskip
\noindent\textbf{Denial of service.} 
Are there any transactions that can be repeatedly called by aggressor clients or a malicious server node, which tie up the network?
To our knowledge, this is not an issue any more than with a traditional web service.

\medskip
\noindent\textbf{Client transaction order.} 
We must ensure that transactions sent from the same client in a particular order are processed in that order---or at least with a bias to that order.
When a client sends two transactions to the same node, that receiving node could change their order before writing them to the backlog. That wrong ordering would probably be preserved by the RethinkDB changelog, so all other nodes would see the same wrong ordering. At the time of writing, we were considering several possible solutions, including using multi-node consensus on client-provided timestamps.

\medskip
\noindent\textbf{Database built-in communication vulnerability.} 
The nodes communicate using the big data DB’s own built-in consensus algorithm like Paxos to tolerate benign failures. 
Is this a vulnerability? The answer is that many nodes would have to be affected for it to have any major consequences.

\medskip
\noindent\textbf{Double spends.} 
Are there any ways to double-spend? 
This is a useful question to keep asking at all stages of development. 
In this regard BigchainDB does exactly the same as the Bitcoin network. All past transactions are checked to make sure that input was not already spent. This can be fast for BigchainDB because it can use an optimized query of the underlying DB.

\medskip
\noindent\textbf{Malicious behavior.} 
Questions: How does BigchainDB detect that a node has bad (Byzantine) behavior? 
Does it discourage bad behavior? How? 
Answers: Overall, it’s a simpler problem because of the federation model. 
Bad behavior can be detected when a node’s vote on a block is different than the majority. 
There are many possible ways to discourage bad behavior, from manual punishment decided by the federation, to needing to post a security deposit (bond) and automatically losing it upon bad behavior. 

\medskip
\noindent\textbf{Admin becoming god.} 
Does the system administrator have any powers that allow them to play “god”, and thus constitute a single point of failure? 
We were careful to limit the power of the system administrator to even less than a voting node. 
So to our knowledge, the system administrator cannot play god because all write transactions (including updating software) need to be voted on by the federation. 

\medskip
\noindent\textbf{Offline nodes.} 
Q: What happens if a voting node goes offline? If many go offline? 
A: One or a few offline nodes is fine, as a quorum (the number of nodes needed to decide a block) is still online. 
If there are many offline nodes, then a block could get stuck in an undecided state. (Transactions depending on transactions in the undecided block would also get stuck in the backlog.)
Our solution is to wait until enough nodes come back online to vote on and decide the block. It is a reasonable solution, because all consensus algorithms require some minumum proportion of nodes to be online to work.
An alternative solution would be to limit the amount of time that a block can be undecided before being marked \textsf{\textit{decided\_invalid}}, so that all its transactions can be copied back to the backlog for reconsideration.

\medskip
\noindent\textbf{Chaining blocks rather than transactions.} 
Q: Why do we chain together blocks, rather than chaining together transactions? 
A: There are several reasons.
First, it's easier to write $1000$ blocks per second (each containing up to $1000$ transactions) than it is to write $1$~million transactions per second (to the blockchain database).
Second, each voting node only has to append a vote (data structure) to each block, rather than to each transaction, saving a lot of storage space. (If a voting node votes yes for a block, then we can conclude that it found all the contained transactions to be valid.) Lastly, when constructing a vote, the signing node must compute a cryptographic signature. That takes time. We save time by doing that only once per block (rather than per transaction).


\subsection{Transaction Validity, Incentivization, and Native Assets}
There are many things to check when determining if a transaction is valid. Signatures must be valid. Certain fields must be present (and no others). Various values must have the correct syntax.
If the transaction is to create or register a new asset, then the same asset must not already exist.
If the transaction is to transfer an asset, then the asset must exist, the transfer transaction must be requested by the current owner (who must sign it with their private key), not by a previous owner and not by a non-owner. ``You can only spend what you have.''

Every voting node checks the validity of every transaction (so it can decide how to vote on the transaction's block). 
Recall that BigchainDB consensus is federation-based.
A node gets to vote on a transaction based on whether it has been given a voting node role.
Contrast this to a POW model, where the probability of a node voting is proportional to its hash power, which assuming all miners have state-of-the-art hardware is equivalent to electricity spent; or to POS where probability of a node voting is proportional to how much money it has.

Traditionally, blockchains have held two types of assets. 
“Native assets,” like Bitcoins or Ether, are built into the core protocol. 
The consensus uses these assets to measure transaction validity and to reward voting by native-asset transaction fees and mining rewards. 
Second are non-native “overlay assets” in overlay protocols sitting above the core protocol (e.g.~SPOOL \cite{dejonghe_spool}).
However, this traditional approach to native assets and reward has weaknesses:

\begin{itemize}
 \item \textbf{Overlay Asset Double-Spend.} Traditional blockchains’ consensus models do not account for overlay assets. There is nothing at the core protocol level to prevent a double-spend of an overlay asset.
 \item \textbf{Native Asset Friction to Network Participation.} Traditional blockchain voting nodes need to get paid in the native asset, so any new participants in the network must acquire the native asset, typically on an exchange, before being able to conduct a transaction. Acquiring the native asset is especially difficult on newer blockchains with native assets that are not yet available on many exchanges. This is a high barrier to entry when compared to traditional web services, where any new participant can conduct a transaction by paying in a standard currency like U.S. dollars with a standard payment method like a credit card.
\end{itemize}

BigchainDB overcomes these issues as follows (and as shown in Table \ref{tab:bigchain_comparison_assets}):
\begin{itemize}
 \item \textbf{Native consensus voting on every asset.} Every transaction keeps track of which asset it is operating on, chaining back to the transaction that issued the asset. Every asset is “native” in the sense that it’s used to measure transaction validity. This overcomes the issue of “asset overlay double-spend.”
 \item \textbf{Low friction to network participation.} Like a traditional web service, the network operator sets the terms on how to join the network and conduct transactions—but in this case the network operator is the collective will of the voting nodes. The voting nodes also determine how users pay for transactions.
\end{itemize}

\begin{table}[h]
  \caption{Native Assets Validity \& Incentivization}
  \footnotesize
  \makebox[\textwidth][c]{
  \centering
  \setlength\extrarowheight{3pt}
  \begin{tabular}{ | m{\dimexpr 0.3\linewidth-2\tabcolsep} |
	  M{\dimexpr 0.175\linewidth-2\tabcolsep} |
	  M{\dimexpr 0.175\linewidth-2\tabcolsep} |
	  M{\dimexpr 0.175\linewidth-2\tabcolsep} |
	  M{\dimexpr 0.175\linewidth-2\tabcolsep} |} \Xhline{4\arrayrulewidth}\rowcolor{black}
  		                    & \multicolumn{2}{|c|}{\color{white} Traditional Blockchain} & \multicolumn{2}{|c|}{\color{white} BigchainDB} \\\Xhline{4\arrayrulewidth}\rowcolor{backcolour}
  		                    & Native Asset & Overlay Assets & Native Asset & Overlay Assets \\\Xhline{2\arrayrulewidth}
  Asset Types 			    & Y (one)	   & Y (multiple)   & Y (multiple) & N          \\\hline
  Validated by Blockchain Consensus & Y 	   & N              & Y            & N/A        \\\hline
  Incentivization Via               & \multicolumn{2}{|M{\dimexpr 0.35\linewidth-2\tabcolsep}|}{Native Asset \makebox{(e.g. Mining Reward)}} & \multicolumn{2}{M{\dimexpr 0.35\linewidth-2\tabcolsep}|}{External Fees \makebox{(e.g. Transactions, Storage)}} \\\hline
  Payment for Transactions          & \multicolumn{2}{|M{\dimexpr 0.35\linewidth-2\tabcolsep}|}{Obtain Native Assets \makebox{(e.g. Via an Exchange)}} & \multicolumn{2}{M{\dimexpr 0.35\linewidth-2\tabcolsep}|}{Fiat Currency \makebox{(e.g. Traditional channels)}} \\\hline
  \Xhline{4\arrayrulewidth}
  \end{tabular}
  }
  \label{tab:bigchain_comparison_assets}
\end{table}

\subsection{Incentivization \& Security}
In POW and POS blockchains, the network, incentive model, and security of the network are inextricably linked. Security is intrinsic to the system.
But as discussed in section \ref{sec:background} and appendix \ref{appendix:blockchain_scalability}, both POW and POS have scalability challenges.
Though it’s a double-edged sword: when incentives are intrinsic to the system too, there is motivation to game the system.
An example is the emergence of mining pools to benefit the most from Bitcoin’s built-in incentive (mining rewards).

In a federation like BigchainDB, the security of each node and aggregate security over the entire network are extrinsic.
This means the rules for confidentiality, availability, and integrity are outside the core network design \cite{gault2015cia_secret}.
For instance, if all nodes have weak rules for security, the network will be breached.
By contrast, if a minimum fraction of the network nodes have reasonable security standards, the network as a whole can withstand attacks.
Extrinsic incentives can have benefits: in a private deployment, the network participants are motivated simply by the benefits of being part of the network (e.g. lower costs, lower fraud, new functionality).
Extrinsic incentives can work in a public deployment too, for similar reasons: the voting nodes may have their own reasons for an open, public database to survive, for example a mandate as a nonprofit, and this makes the interests aligned (see also section \ref{subsec:permissioning_public}).